---
title: "Variables & Types"
description: "Explains how programming languages bind identifiers to typed data and what guarantees that provides."
course: "cs-101"
concept: "computer-science/variables"
order: 1
durationMinutes: 45
objectives:
  - "Differentiate between identifiers, storage locations, and values."
  - "Classify primitive and composite data types in a statically typed language."
  - "Predict how type constraints influence variable initialization and mutation."
exercises: []
notes: []
---

## Overview
Variables provide named access to storage locations, while types constrain the set of admissible values that may inhabit those locations. A well-designed type system balances expressiveness with safety, enabling compilers and interpreters to detect misuse early. This lesson outlines the conceptual foundations of variables and types as they appear in mainstream imperative languages.

## Intuition
Programmers rely on variables as symbolic handles for evolving state. By associating each handle with a type, languages communicate expectations about representation (bit width, encoding) and operations (permitted arithmetic, comparisons). The intuition is that types serve as contracts; once a variable is declared with a type, any subsequent assignment or operation must honor that contract to preserve program invariants.

## Formalism
Formally, a variable declaration introduces a binding in an environment \( \Gamma \) that maps identifiers to type schemes. An assignment statement updates the store \( \sigma \) at the address referenced by the binding, provided the assigned value inhabits the declared type. Type systems are often expressed via inference rules such as the typing judgment \( \Gamma \vdash e : \tau \), meaning expression \( e \) has type \( \tau \) under environment \( \Gamma \). Soundness of these rules guarantees progress (well-typed programs do not get stuck) and preservation (types remain valid after evaluation steps).

## Examples
Consider a statically typed language similar to TypeScript:

```ts
let count: number = 0;
const label: string = "items";
let stats: { total: number; average: number } = { total: 0, average: 0 };
```

Here, `count` is mutable because it was declared with `let`, and its type restricts it to numeric updates. `label` is immutable due to `const`, freezing both the identifier binding and the string type. The `stats` object demonstrates a composite type where each property carries its own type annotation, ensuring structured data adheres to the specified schema.

## Exercises
1. Given the typing context `Γ = { x: boolean, y: number }`, determine whether the expression `x ? y : 0` type-checks and justify the result using the conditional typing rule.
2. Reformulate the object example above so that `stats` becomes immutable yet still records updates through a new object each time, explaining how persistent data structures maintain type safety.
3. Design a small set of inference rules for a `let`-binding with type inference and explain how generalization at `let` introduces polymorphism without sacrificing soundness.

## References
- Benjamin C. Pierce, *Types and Programming Languages*. MIT Press, 2002.
- Robert Harper, *Practical Foundations for Programming Languages*. Cambridge University Press, 2016.
- Robin Milner, "A Theory of Type Polymorphism in Programming." *Journal of Computer and System Sciences* 17, no. 3 (1978): 348–375.
